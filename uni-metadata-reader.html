<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal File Metadata Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #f59e0b;
            --accent: #ec4899;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --bg-primary: #0a0a14;
            --bg-secondary: #151529;
            --bg-tertiary: #1f1f3d;
            --text-primary: #ffffff;
            --text-secondary: #a3a3a3;
            --border: #3a3a5a;
            --shadow: rgba(99, 102, 241, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --neon-glow: rgba(236, 72, 153, 0.4);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: 
                radial-gradient(circle at 20% 80%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(245, 158, 11, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 100px,
                    rgba(99, 102, 241, 0.02) 101px,
                    rgba(99, 102, 241, 0.02) 102px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 100px,
                    rgba(236, 72, 153, 0.02) 101px,
                    rgba(236, 72, 153, 0.02) 102px
                );
            z-index: -2;
            pointer-events: none;
        }

        .footer {
            text-align: center;
            margin-top: 4rem;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 0.5Spx;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            margin-bottom: 2rem;
        }

        .footer-text {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 500;
            background: linear-gradient(000deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-top: 1rem;
            letter-spacing: 0.5px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            text-align: center;
            display: block;
            width: 100%;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
            top: 140px;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--secondary));
            border-radius: 2px;
            box-shadow: 0 0 20px rgba(236, 72, 153, 0.6);
            animation: line-glow 3s ease-in-out infinite;
            
        }

        @keyframes line-glow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(99, 102, 241, 0.6);
                transform: translateX(-50%) scaleX(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(236, 72, 153, 0.8);
                transform: translateX(-50%) scaleX(1.2);
            }
        }

        .header h1 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--accent), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            letter-spacing: -0.02em;
            position: relative;
            animation: glow-pulse 4s ease-in-out infinite;
            
        }

        @keyframes glow-pulse {
            0%, 100% { 
                filter: drop-shadow(0 0 20px rgba(99, 102, 241, 0.5));
            }
            50% { 
                filter: drop-shadow(0 0 30px rgba(236, 72, 153, 0.7));
            }
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-secondary);
            font-weight: 400;
           
        }

        .upload-section {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 3rem;
            margin-bottom: 2rem;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
                top: 180px;
        }

        .upload-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s;
        }

        .upload-section:hover::before {
            left: 100%;
        }

        .upload-section:hover::before {
            left: 100%;
        }

        .upload-section:hover {
            border-color: var(--primary);
            box-shadow: 
                0 20px 40px var(--shadow),
                0 0 60px rgba(99, 102, 241, 0.3);
            transform: translateY(-4px);
        }

        .upload-section.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
            transform: scale(1.02);
            box-shadow: 0 0 80px rgba(99, 102, 241, 0.4);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            display: block;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .upload-text {
            font-size: 1.375rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .upload-subtext {
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-size: 1rem;
        }

        .supported-formats {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .format-tag {
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 20px rgba(99, 102, 241, 0.3),
                0 0 0 0 rgba(236, 72, 153, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 30px rgba(99, 102, 241, 0.4),
                0 0 40px rgba(236, 72, 153, 0.6);
        }

        .file-input {
            display: none;
        }

        .progress-container {
            margin-bottom: 2rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .progress-container.visible {
            opacity: 1;
            visibility: visible;
        }

        .progress-bar {
            background: var(--bg-tertiary);
            border-radius: 12px;
            height: 8px;
            overflow: hidden;
            position: relative;
            bottom: 700px;
        }

        .progress-fill {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            height: 100%;
            width: 0%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .alert {
            padding: 3rem 1.5rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            font-weight: 500;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            transform: translateY(-10px);
            
        }

        .alert.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .alert.error {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.2);
            
        }

        .alert.success {
            background: rgba(16, 185, 129, 0.1);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.2);
            
        }

        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(20px);
            position: relative;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--secondary));
            border-radius: 20px 20px 0 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 
                0 20px 40px var(--shadow),
                0 0 60px rgba(99, 102, 241, 0.2);
        }

        .card:hover::before {
            opacity: 1;
        }

        .card h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-grid {
            display: grid;
            gap: 1rem;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .info-item:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: var(--primary);
        }

        .info-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-value {
            font-size: 1rem;
            color: var(--text-primary);
            word-break: break-word;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
        }

        .metadata-tree {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            padding: 1.5rem;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
        }

        .metadata-tree::-webkit-scrollbar {
            width: 8px;
        }

        .metadata-tree::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .metadata-tree::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        .json-key {
            color: #8dd3c7;
            font-weight: 600;
        }

        .json-string {
            color: #ffffb3;
        }

        .json-number {
            color: #bebada;
        }

        .json-boolean {
            color: #fb8072;
        }

        .json-null {
            color: #80b1d3;
        }

        .export-actions {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .export-btn {
            background: linear-gradient(135deg, var(--secondary), #d97706);
            color: white;
            border: none;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
        }

                                                                                         /* Debug section is hidden rn */

        .debug-section {
            margin-top: 2rem;
            visibility: hidden;
        }

        .debug-toggle {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .debug-toggle:hover {
            color: var(--text-primary);
            border-color: var(--primary);
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.875rem;
            max-height: 300px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .debug-info.visible {
            opacity: 1;
            visibility: visible;
        }

        .debug-info div {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(99, 102, 241, 0.2);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .particle {
            position: fixed;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, var(--accent), var(--primary));
            border-radius: 50%;
            pointer-events: none;
            z-index: -1;
            animation: particle-float 8s linear infinite;
            box-shadow: 0 0 10px currentColor;
        }

        @keyframes particle-float {
            0% {
                opacity: 0;
                transform: translateY(100vh) rotate(0deg) scale(0.5);
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) rotate(36deg) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translateY(50vh) rotate(180deg) scale(0.8);
            }
            90% {
                opacity: 0.3;
                transform: translateY(10vh) rotate(324deg) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-10vh) rotate(360deg) scale(0.3);
            }
        }

        /* Floating geometric shapes */
        .geometric-shape {
            position: fixed;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
            animation: float-geometric 15s ease-in-out infinite;
        }

        .geometric-shape.triangle {
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid var(--accent);
        }

        .geometric-shape.square {
            width: 20px;
            height: 20px;
            background: var(--primary);
            transform: rotate(45deg);
        }

        .geometric-shape.circle {
            width: 18px;
            height: 18px;
            background: var(--secondary);
            border-radius: 50%;
        }

        @keyframes float-geometric {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
                opacity: 0.1;
            }
            50% {
                transform: translateY(-20px) rotate(180deg);
                opacity: 0.3;
            }
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
            
            .export-actions {
                flex-direction: column;
            }
            
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>File Metadata Reader</h1>
            <p>Universal file format analyzer and metadata extractor</p>
        </div>

        <div class="upload-section" id="uploadArea">
            <div class="upload-icon">📄</div>
            <div class="upload-text">Drop any file here</div>
            <div class="upload-subtext">Analyze metadata from various file formats</div>
            
            <div class="supported-formats">
                <span class="format-tag">Images (JPEG, PNG, GIF, TIFF, BMP)</span>
                <span class="format-tag">Videos (MP4, AVI, MOV, MKV)</span>
                <span class="format-tag">Audio (MP3, FLAC, WAV, OGG)</span>
                <span class="format-tag">Documents (PDF, DOCX, XLSX)</span>
                <span class="format-tag">Archives (ZIP, RAR, 7Z)</span>
                <span class="format-tag">Gaming (PKG, ISO, ROM)</span>
                <span class="format-tag">Executables (EXE, ELF, DMG)</span>
                <span class="format-tag">And many more...</span>
            </div>
            
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                Choose File
            </button>
            <input type="file" id="fileInput" class="file-input" onchange="handleFileSelect(event)">
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="alert error" id="errorAlert"></div>
        <div class="alert success" id="successAlert"></div>

        <div class="content-grid">
            <div class="card" id="basicInfoCard">
                <h3>📊 Basic Information</h3>
                <div class="info-grid" id="basicInfoGrid"></div>
            </div>

            <div class="card" id="technicalInfoCard">
                <h3>⚙️ Technical Details</h3>
                <div class="info-grid" id="technicalInfoGrid"></div>
            </div>

            <div class="card" id="metadataCard">
                <h3>🏷️ Extracted Metadata</h3>
                <div class="metadata-tree" id="metadataTree"></div>
                <div class="export-actions">
                    <button class="export-btn" onclick="exportMetadata('json')">
                        📄 Export as JSON
                    </button>
                    <button class="export-btn" onclick="exportMetadata('csv')">
                        📊 Export as CSV
                    </button>
                    <button class="export-btn" onclick="exportMetadata('xml')">
                        📋 Export as XML
                    </button>
                </div>
            </div>

            <div class="card" id="hexViewCard">
                <h3>🔍 Hex Preview</h3>
                <div class="metadata-tree" id="hexView"></div>
            </div>
        </div>

        <div class="debug-section">
            <button class="debug-toggle" onclick="toggleDebug()">Toggle Debug Info</button>
            <div class="debug-info" id="debugInfo"></div>
        </div>

        <div class="footer">
            <span class="footer-text">Made with ❤️ by nath</span>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const errorAlert = document.getElementById('errorAlert');
        const successAlert = document.getElementById('successAlert');
        const basicInfoCard = document.getElementById('basicInfoCard');
        const technicalInfoCard = document.getElementById('technicalInfoCard');
        const metadataCard = document.getElementById('metadataCard');
        const hexViewCard = document.getElementById('hexViewCard');
        const basicInfoGrid = document.getElementById('basicInfoGrid');
        const technicalInfoGrid = document.getElementById('technicalInfoGrid');
        const metadataTree = document.getElementById('metadataTree');
        const hexView = document.getElementById('hexView');
        const debugInfo = document.getElementById('debugInfo');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let currentFileData = null;
        let currentMetadata = {};
        let debugLog = [];

        // Initialize particles with better cleanup
        function createParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 6 + 's';
            document.body.appendChild(particle);
            
            // Clean up particle after animation completes
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.remove();
                }
            }, 6000);
        }

        // Create particles less frequently and clean up existing ones
        let particleInterval = setInterval(() => {
            // Limit total particles on screen
            const existingParticles = document.querySelectorAll('.particle');
            if (existingParticles.length < 5) {
                createParticle();
            }
        }, 4000);

        // Drag and drop functionality
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function showAlert(message, type = 'error') {
            const alert = type === 'error' ? errorAlert : successAlert;
            alert.textContent = message;
            alert.classList.add('visible');
            
            setTimeout(() => {
                alert.classList.remove('visible');
            }, 5000);
        }

        function showProgress(percent) {
            progressContainer.classList.add('visible');
            progressFill.style.width = percent + '%';
        }

        function hideProgress() {
            setTimeout(() => {
                progressContainer.classList.remove('visible');
            }, 500);
        }

        function showLoading() {
            loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            loadingOverlay.classList.remove('visible');
        }

        function log(message) {
            debugLog.push(`[${new Date().toLocaleTimeString()}] ${message}`);
            console.log(message);
            updateDebugInfo();
        }

        function updateDebugInfo() {
            debugInfo.innerHTML = debugLog.map(msg => `<div>${msg}</div>`).join('');
            debugInfo.scrollTop = debugInfo.scrollHeight;
        }

        function toggleDebug() {
            debugInfo.classList.toggle('visible');
        }

        function handleFile(file) {
            debugLog = [];
            log(`Analyzing file: ${file.name} (${formatBytes(file.size)})`);
            showLoading();
            showProgress(0);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    showProgress(25);
                    const arrayBuffer = e.target.result;
                    const dataView = new DataView(arrayBuffer);
                    currentFileData = dataView;
                    
                    log('Extracting basic information...');
                    showProgress(50);
                    const basicInfo = extractBasicInfo(file, dataView);
                    
                    log('Analyzing file format and metadata...');
                    showProgress(75);
                    const metadata = analyzeFileFormat(file, dataView);
                    currentMetadata = metadata;
                    
                    showProgress(100);
                    setTimeout(() => {
                        hideProgress();
                        hideLoading();
                        displayBasicInfo(basicInfo);
                        displayTechnicalInfo(metadata.technical);
                        displayMetadata(metadata.extracted);
                        displayHexPreview(dataView);
                        showCards();
                        showAlert('File analysis completed successfully!', 'success');
                        log('Analysis complete!');
                    }, 500);
                    
                } catch (error) {
                    hideProgress();
                    hideLoading();
                    log(`ERROR: ${error.message}`);
                    showAlert('Error analyzing file: ' + error.message, 'error');
                }
            };
            
            reader.onerror = function() {
                hideProgress();
                hideLoading();
                showAlert('Error reading file', 'error');
            };
            
            reader.readAsArrayBuffer(file);
        }

        function showCards() {
            setTimeout(() => basicInfoCard.classList.add('visible'), 100);
            setTimeout(() => technicalInfoCard.classList.add('visible'), 200);
            setTimeout(() => metadataCard.classList.add('visible'), 300);
            setTimeout(() => hexViewCard.classList.add('visible'), 400);
        }

        function extractBasicInfo(file, dataView) {
            const info = {
                name: file.name,
                size: file.size,
                type: file.type || 'Unknown',
                lastModified: new Date(file.lastModified).toLocaleString(),
                extension: file.name.split('.').pop().toUpperCase(),
                md5: 'Calculating...',
                sha1: 'Calculating...'
            };

            // Calculate simple checksums for first 1KB
            const sampleSize = Math.min(1024, dataView.byteLength);
            let simpleHash = 0;
            for (let i = 0; i < sampleSize; i++) {
                simpleHash = ((simpleHash << 5) - simpleHash + dataView.getUint8(i)) & 0xffffffff;
            }
            info.simpleHash = simpleHash.toString(16).toUpperCase();

            return info;
        }

        function analyzeFileFormat(file, dataView) {
            const extension = file.name.split('.').pop().toLowerCase();
            const magic = getMagicBytes(dataView);
            
            log(`File extension: ${extension}`);
            log(`Magic bytes: ${magic}`);

            const metadata = {
                technical: {
                    fileSignature: magic,
                    detectedFormat: detectFileFormat(magic, extension),
                    byteOrder: detectByteOrder(dataView),
                    entropy: calculateEntropy(dataView),
                    compression: detectCompression(dataView)
                },
                extracted: {}
            };

            // Format-specific analysis
            switch (extension) {
                case 'jpg':
                case 'jpeg':
                    metadata.extracted = analyzeJPEG(dataView);
                    break;
                case 'png':
                    metadata.extracted = analyzePNG(dataView);
                    break;
                case 'gif':
                    metadata.extracted = analyzeGIF(dataView);
                    break;
                case 'pdf':
                    metadata.extracted = analyzePDF(dataView);
                    break;
                case 'mp3':
                    metadata.extracted = analyzeMP3(dataView);
                    break;
                case 'mp4':
                    metadata.extracted = analyzeMP4(dataView);
                    break;
                case 'zip':
                    metadata.extracted = analyzeZIP(dataView);
                    break;
                case 'pkg':
                    metadata.extracted = analyzePKG(dataView);
                    break;
                case 'exe':
                    metadata.extracted = analyzeEXE(dataView);
                    break;
                case 'elf':
                    metadata.extracted = analyzeELF(dataView);
                    break;
                default:
                    metadata.extracted = analyzeGeneric(dataView);
            }

            return metadata;
        }

        function getMagicBytes(dataView, length = 16) {
            const bytes = [];
            const maxLength = Math.min(length, dataView.byteLength);
            for (let i = 0; i < maxLength; i++) {
                bytes.push(dataView.getUint8(i).toString(16).padStart(2, '0').toUpperCase());
            }
            return bytes.join(' ');
        }

        function detectFileFormat(magic, extension) {
            const signatures = {
                'FF D8 FF': 'JPEG Image',
                '89 50 4E 47': 'PNG Image',
                '47 49 46 38': 'GIF Image',
                '25 50 44 46': 'PDF Document',
                '50 4B 03 04': 'ZIP Archive',
                '50 4B 05 06': 'ZIP Archive (Empty)',
                '50 4B 07 08': 'ZIP Archive (Spanned)',
                '7F 45 4C 46': 'ELF Executable',
                '4D 5A': 'Windows Executable',
                '7F 50 4B 47': 'PlayStation PKG',
                'ID3': 'MP3 Audio',
                '00 00 00 18 66 74 79 70': 'MP4 Video',
                '52 49 46 46': 'RIFF Container (AVI/WAV)'
            };

            for (const [sig, format] of Object.entries(signatures)) {
                if (magic.startsWith(sig)) {
                    return format;
                }
            }

            return `${extension.toUpperCase()} File`;
        }

        function detectByteOrder(dataView) {
            if (dataView.byteLength < 4) return 'Unknown';
            
            // Look for BOM or common patterns
            const first4 = dataView.getUint32(0, false);
            if (first4 === 0xFEFF0000 || first4 === 0x0000FEFF) {
                return 'Big Endian (UTF-32)';
            }
            if (first4 === 0xFFFE0000 || first4 === 0x0000FFFE) {
                return 'Little Endian (UTF-32)';
            }
            
            // Check first two bytes for UTF-16 BOM
            const first2 = dataView.getUint16(0, false);
            if (first2 === 0xFEFF) return 'Big Endian (UTF-16)';
            if (first2 === 0xFFFE) return 'Little Endian (UTF-16)';
            
            return 'Unknown/Mixed';
        }

        function calculateEntropy(dataView) {
            const sampleSize = Math.min(4096, dataView.byteLength);
            const frequency = new Array(256).fill(0);
            
            for (let i = 0; i < sampleSize; i++) {
                frequency[dataView.getUint8(i)]++;
            }
            
            let entropy = 0;
            for (let i = 0; i < 256; i++) {
                if (frequency[i] > 0) {
                    const p = frequency[i] / sampleSize;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy.toFixed(3);
        }

        function detectCompression(dataView) {
            const magic = getMagicBytes(dataView, 4);
            
            if (magic.startsWith('1F 8B')) return 'GZIP';
            if (magic.startsWith('42 5A 68')) return 'BZIP2';
            if (magic.startsWith('78 9C') || magic.startsWith('78 01') || magic.startsWith('78 DA')) return 'ZLIB';
            if (magic.startsWith('50 4B')) return 'ZIP/DEFLATE';
            if (magic.startsWith('37 7A BC AF')) return '7-Zip';
            if (magic.startsWith('FD 37 7A 58 5A')) return 'XZ';
            
            return 'None/Unknown';
        }

        function analyzeJPEG(dataView) {
            const metadata = {
                format: 'JPEG',
                width: null,
                height: null,
                colorSpace: null,
                quality: null,
                exifData: {}
            };

            try {
                let offset = 2; // Skip SOI marker
                
                while (offset < dataView.byteLength - 4) {
                    const marker = dataView.getUint16(offset, false);
                    const length = dataView.getUint16(offset + 2, false);
                    
                    if ((marker & 0xFFC0) === 0xFFC0 && marker !== 0xFFC4) {
                        // SOF marker - contains image dimensions
                        metadata.height = dataView.getUint16(offset + 5, false);
                        metadata.width = dataView.getUint16(offset + 7, false);
                        metadata.colorComponents = dataView.getUint8(offset + 9);
                        break;
                    }
                    
                    offset += 2 + length;
                }
            } catch (e) {
                log(`JPEG analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzePNG(dataView) {
            const metadata = {
                format: 'PNG',
                width: null,
                height: null,
                bitDepth: null,
                colorType: null,
                compression: null,
                filter: null,
                interlace: null,
                chunks: []
            };

            try {
                if (getMagicBytes(dataView, 8) === '89 50 4E 47 0D 0A 1A 0A') {
                    // IHDR chunk starts at offset 8
                    metadata.width = dataView.getUint32(16, false);
                    metadata.height = dataView.getUint32(20, false);
                    metadata.bitDepth = dataView.getUint8(24);
                    metadata.colorType = dataView.getUint8(25);
                    metadata.compression = dataView.getUint8(26);
                    metadata.filter = dataView.getUint8(27);
                    metadata.interlace = dataView.getUint8(28);
                    
                    // Parse chunks
                    let offset = 8;
                    while (offset < dataView.byteLength - 8) {
                        const chunkLength = dataView.getUint32(offset, false);
                        const chunkType = String.fromCharCode(
                            dataView.getUint8(offset + 4),
                            dataView.getUint8(offset + 5),
                            dataView.getUint8(offset + 6),
                            dataView.getUint8(offset + 7)
                        );
                        
                        metadata.chunks.push({
                            type: chunkType,
                            length: chunkLength,
                            offset: offset
                        });
                        
                        offset += 12 + chunkLength;
                        if (chunkType === 'IEND') break;
                    }
                }
            } catch (e) {
                log(`PNG analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeGIF(dataView) {
            const metadata = {
                format: 'GIF',
                version: null,
                width: null,
                height: null,
                globalColorTable: false,
                colorResolution: null,
                backgroundColorIndex: null,
                pixelAspectRatio: null
            };

            try {
                const signature = String.fromCharCode(
                    dataView.getUint8(0), dataView.getUint8(1), dataView.getUint8(2)
                );
                const version = String.fromCharCode(
                    dataView.getUint8(3), dataView.getUint8(4), dataView.getUint8(5)
                );
                
                if (signature === 'GIF') {
                    metadata.version = version;
                    metadata.width = dataView.getUint16(6, true);
                    metadata.height = dataView.getUint16(8, true);
                    
                    const packed = dataView.getUint8(10);
                    metadata.globalColorTable = !!(packed & 0x80);
                    metadata.colorResolution = ((packed & 0x70) >> 4) + 1;
                    metadata.backgroundColorIndex = dataView.getUint8(11);
                    metadata.pixelAspectRatio = dataView.getUint8(12);
                }
            } catch (e) {
                log(`GIF analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzePDF(dataView) {
            const metadata = {
                format: 'PDF',
                version: null,
                objects: 0,
                encrypted: false,
                linearized: false,
                pageCount: null
            };

            try {
                // Get PDF version from header
                const header = new TextDecoder().decode(dataView.buffer.slice(0, 8));
                const versionMatch = header.match(/%PDF-(\d\.\d)/);
                if (versionMatch) {
                    metadata.version = versionMatch[1];
                }

                // Look for encryption and linearization hints
                const sample = new TextDecoder().decode(dataView.buffer.slice(0, Math.min(4096, dataView.byteLength)));
                metadata.encrypted = sample.includes('/Encrypt');
                metadata.linearized = sample.includes('/Linearized');
                
                // Count objects (rough estimate)
                const objectMatches = sample.match(/\d+ \d+ obj/g);
                metadata.objects = objectMatches ? objectMatches.length : 0;
            } catch (e) {
                log(`PDF analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeMP3(dataView) {
            const metadata = {
                format: 'MP3',
                version: null,
                layer: null,
                bitrate: null,
                sampleRate: null,
                channels: null,
                id3Tags: {}
            };

            try {
                // Look for ID3v2 header
                if (dataView.getUint8(0) === 0x49 && dataView.getUint8(1) === 0x44 && dataView.getUint8(2) === 0x33) {
                    metadata.id3Tags.version = `2.${dataView.getUint8(3)}.${dataView.getUint8(4)}`;
                    const size = ((dataView.getUint8(6) & 0x7F) << 21) |
                               ((dataView.getUint8(7) & 0x7F) << 14) |
                               ((dataView.getUint8(8) & 0x7F) << 7) |
                               (dataView.getUint8(9) & 0x7F);
                    metadata.id3Tags.size = size;
                }

                // Look for MPEG frame header
                for (let i = 0; i < Math.min(4096, dataView.byteLength - 4); i++) {
                    if (dataView.getUint8(i) === 0xFF && (dataView.getUint8(i + 1) & 0xE0) === 0xE0) {
                        const header = dataView.getUint32(i, false);
                        
                        const version = (header >> 19) & 0x3;
                        const layer = (header >> 17) & 0x3;
                        const bitrateIndex = (header >> 12) & 0xF;
                        const sampleRateIndex = (header >> 10) & 0x3;
                        const channelMode = (header >> 6) & 0x3;
                        
                        metadata.version = version === 3 ? '1' : version === 2 ? '2' : version === 0 ? '2.5' : 'Unknown';
                        metadata.layer = 4 - layer;
                        metadata.channels = channelMode === 3 ? 1 : 2;
                        
                        break;
                    }
                }
            } catch (e) {
                log(`MP3 analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeMP4(dataView) {
            const metadata = {
                format: 'MP4',
                brand: null,
                version: null,
                duration: null,
                tracks: [],
                atoms: []
            };

            try {
                let offset = 0;
                while (offset < dataView.byteLength - 8) {
                    const atomSize = dataView.getUint32(offset, false);
                    const atomType = String.fromCharCode(
                        dataView.getUint8(offset + 4),
                        dataView.getUint8(offset + 5),
                        dataView.getUint8(offset + 6),
                        dataView.getUint8(offset + 7)
                    );
                    
                    metadata.atoms.push({
                        type: atomType,
                        size: atomSize,
                        offset: offset
                    });
                    
                    if (atomType === 'ftyp' && atomSize >= 16) {
                        metadata.brand = String.fromCharCode(
                            dataView.getUint8(offset + 8),
                            dataView.getUint8(offset + 9),
                            dataView.getUint8(offset + 10),
                            dataView.getUint8(offset + 11)
                        );
                        metadata.version = dataView.getUint32(offset + 12, false);
                    }
                    
                    if (atomSize === 0) break;
                    offset += atomSize;
                }
            } catch (e) {
                log(`MP4 analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeZIP(dataView) {
            const metadata = {
                format: 'ZIP',
                entries: [],
                compression: [],
                comment: null
            };

            try {
                let offset = 0;
                while (offset < dataView.byteLength - 30) {
                    const signature = dataView.getUint32(offset, true);
                    
                    if (signature === 0x04034b50) { // Local file header
                        const version = dataView.getUint16(offset + 4, true);
                        const flags = dataView.getUint16(offset + 6, true);
                        const compression = dataView.getUint16(offset + 8, true);
                        const filenameLength = dataView.getUint16(offset + 26, true);
                        const extraLength = dataView.getUint16(offset + 28, true);
                        
                        const filename = new TextDecoder().decode(
                            dataView.buffer.slice(offset + 30, offset + 30 + filenameLength)
                        );
                        
                        metadata.entries.push({
                            filename: filename,
                            compression: compression,
                            version: version,
                            flags: flags
                        });
                        
                        offset += 30 + filenameLength + extraLength;
                    } else {
                        offset++;
                    }
                    
                    if (metadata.entries.length > 100) break; // Limit for performance
                }
            } catch (e) {
                log(`ZIP analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzePKG(dataView) {
            const metadata = {
                format: 'PlayStation PKG',
                magic: null,
                revision: null,
                type: null,
                contentId: null,
                titleId: null,
                itemCount: null,
                dataSize: null
            };

            try {
                const magic = dataView.getUint32(0, false);
                if (magic === 0x7F504B47) {
                    metadata.magic = '0x' + magic.toString(16).toUpperCase();
                    metadata.revision = dataView.getUint16(4, false);
                    metadata.type = dataView.getUint16(6, false);
                    metadata.itemCount = dataView.getUint32(20, false);
                    metadata.dataSize = Number(dataView.getBigUint64(40, false));
                    
                    // Try to extract metadata
                    const metadataOffset = dataView.getUint32(8, false);
                    const metadataCount = dataView.getUint32(12, false);
                    
                    for (let i = 0; i < metadataCount && i < 20; i++) {
                        const entryOffset = metadataOffset + (i * 16);
                        const id = dataView.getUint32(entryOffset, false);
                        const dataOffset = dataView.getUint32(entryOffset + 12, false);
                        const dataSize = dataView.getUint32(entryOffset + 8, false);
                        
                        if (id === 0x1) {
                            metadata.contentId = readNullTerminatedString(dataView, dataOffset, dataSize);
                        } else if (id === 0x7) {
                            metadata.titleId = readNullTerminatedString(dataView, dataOffset, dataSize);
                        }
                    }
                }
            } catch (e) {
                log(`PKG analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeEXE(dataView) {
            const metadata = {
                format: 'Windows Executable',
                dosHeader: {},
                ntHeader: {},
                sections: []
            };

            try {
                // DOS Header
                if (dataView.getUint16(0, true) === 0x5A4D) {
                    metadata.dosHeader.signature = 'MZ';
                    metadata.dosHeader.peOffset = dataView.getUint32(60, true);
                    
                    // PE Header
                    const peOffset = metadata.dosHeader.peOffset;
                    if (dataView.getUint32(peOffset, true) === 0x00004550) {
                        metadata.ntHeader.signature = 'PE';
                        metadata.ntHeader.machine = dataView.getUint16(peOffset + 4, true);
                        metadata.ntHeader.sections = dataView.getUint16(peOffset + 6, true);
                        metadata.ntHeader.timestamp = new Date(dataView.getUint32(peOffset + 8, true) * 1000);
                        metadata.ntHeader.characteristics = dataView.getUint16(peOffset + 22, true);
                    }
                }
            } catch (e) {
                log(`EXE analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeELF(dataView) {
            const metadata = {
                format: 'ELF Executable',
                class: null,
                data: null,
                version: null,
                osAbi: null,
                type: null,
                machine: null,
                entry: null
            };

            try {
                if (dataView.getUint32(0, false) === 0x7F454C46) {
                    metadata.class = dataView.getUint8(4) === 1 ? '32-bit' : '64-bit';
                    metadata.data = dataView.getUint8(5) === 1 ? 'Little Endian' : 'Big Endian';
                    metadata.version = dataView.getUint8(6);
                    metadata.osAbi = dataView.getUint8(7);
                    metadata.type = dataView.getUint16(16, true);
                    metadata.machine = dataView.getUint16(18, true);
                    
                    if (metadata.class === '32-bit') {
                        metadata.entry = '0x' + dataView.getUint32(24, true).toString(16);
                    } else {
                        metadata.entry = '0x' + dataView.getBigUint64(24, true).toString(16);
                    }
                }
            } catch (e) {
                log(`ELF analysis error: ${e.message}`);
            }

            return metadata;
        }

        function analyzeGeneric(dataView) {
            const metadata = {
                format: 'Generic/Unknown',
                textContent: false,
                binaryPatterns: [],
                stringAnalysis: {}
            };

            try {
                // Check if file contains printable text
                const sampleSize = Math.min(1024, dataView.byteLength);
                let printableChars = 0;
                
                for (let i = 0; i < sampleSize; i++) {
                    const byte = dataView.getUint8(i);
                    if ((byte >= 32 && byte <= 126) || byte === 9 || byte === 10 || byte === 13) {
                        printableChars++;
                    }
                }
                
                metadata.textContent = (printableChars / sampleSize) > 0.7;
                
                // Find repeating patterns
                const patterns = new Map();
                for (let i = 0; i < Math.min(2048, dataView.byteLength - 4); i++) {
                    const pattern = dataView.getUint32(i, false);
                    patterns.set(pattern, (patterns.get(pattern) || 0) + 1);
                }
                
                // Get most common patterns
                const sortedPatterns = Array.from(patterns.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                    
                metadata.binaryPatterns = sortedPatterns.map(([pattern, count]) => ({
                    pattern: '0x' + pattern.toString(16).toUpperCase().padStart(8, '0'),
                    occurrences: count
                }));
                
            } catch (e) {
                log(`Generic analysis error: ${e.message}`);
            }

            return metadata;
        }

        function readNullTerminatedString(dataView, offset, maxLength) {
            let str = '';
            for (let i = 0; i < maxLength; i++) {
                const byte = dataView.getUint8(offset + i);
                if (byte === 0) break;
                str += String.fromCharCode(byte);
            }
            return str;
        }

        function displayBasicInfo(info) {
            const items = [
                { label: 'File Name', value: info.name },
                { label: 'File Size', value: formatBytes(info.size) },
                { label: 'MIME Type', value: info.type },
                { label: 'Extension', value: info.extension },
                { label: 'Last Modified', value: info.lastModified },
                { label: 'Simple Hash', value: info.simpleHash }
            ];

            basicInfoGrid.innerHTML = items.map(item => `
                <div class="info-item">
                    <div class="info-label">${item.label}</div>
                    <div class="info-value">${item.value}</div>
                </div>
            `).join('');
        }

        function displayTechnicalInfo(technical) {
            const items = [
                { label: 'File Signature', value: technical.fileSignature },
                { label: 'Detected Format', value: technical.detectedFormat },
                { label: 'Byte Order', value: technical.byteOrder },
                { label: 'Entropy', value: technical.entropy + ' bits' },
                { label: 'Compression', value: technical.compression }
            ];

            technicalInfoGrid.innerHTML = items.map(item => `
                <div class="info-item">
                    <div class="info-label">${item.label}</div>
                    <div class="info-value">${item.value}</div>
                </div>
            `).join('');
        }

        function displayMetadata(metadata) {
            metadataTree.innerHTML = syntaxHighlightJSON(JSON.stringify(metadata, null, 2));
        }

        function displayHexPreview(dataView) {
            const maxBytes = 512;
            const bytesToShow = Math.min(maxBytes, dataView.byteLength);
            let hexString = '';
            
            for (let i = 0; i < bytesToShow; i += 16) {
                const offset = i.toString(16).padStart(8, '0').toUpperCase();
                let hexLine = '';
                let asciiLine = '';
                
                for (let j = 0; j < 16; j++) {
                    if (i + j < bytesToShow) {
                        const byte = dataView.getUint8(i + j);
                        hexLine += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
                        asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    } else {
                        hexLine += '   ';
                        asciiLine += ' ';
                    }
                }
                
                hexString += `<div>${offset}: ${hexLine} | ${asciiLine}</div>`;
            }
            
            if (dataView.byteLength > maxBytes) {
                hexString += `<div style="color: var(--text-secondary); margin-top: 1rem;">... showing first ${maxBytes} bytes of ${dataView.byteLength}</div>`;
            }
            
            hexView.innerHTML = hexString;
        }

        function syntaxHighlightJSON(json) {
            return json
                .replace(/(".*?"):/g, '<span class="json-key">$1</span>:')
                .replace(/: (".*?")/g, ': <span class="json-string">$1</span>')
                .replace(/: (\d+\.?\d*)/g, ': <span class="json-number">$1</span>')
                .replace(/: (true|false)/g, ': <span class="json-boolean">$1</span>')
                .replace(/: (null)/g, ': <span class="json-null">$1</span>');
        }

        function exportMetadata(format) {
            if (!currentMetadata) {
                showAlert('No metadata to export', 'error');
                return;
            }

            let content = '';
            let filename = '';
            let mimeType = '';

            switch (format) {
                case 'json':
                    content = JSON.stringify(currentMetadata, null, 2);
                    filename = 'metadata.json';
                    mimeType = 'application/json';
                    break;
                case 'csv':
                    content = jsonToCSV(currentMetadata);
                    filename = 'metadata.csv';
                    mimeType = 'text/csv';
                    break;
                case 'xml':
                    content = jsonToXML(currentMetadata);
                    filename = 'metadata.xml';
                    mimeType = 'application/xml';
                    break;
            }

            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showAlert(`Metadata exported as ${format.toUpperCase()}!`, 'success');
        }

        function jsonToCSV(obj, prefix = '') {
            let csv = '';
            
            function flatten(obj, prefix = '') {
                const flattened = {};
                for (const key in obj) {
                    const newKey = prefix ? `${prefix}.${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                        Object.assign(flattened, flatten(obj[key], newKey));
                    } else {
                        flattened[newKey] = obj[key];
                    }
                }
                return flattened;
            }
            
            const flattened = flatten(obj);
            const headers = Object.keys(flattened);
            const values = Object.values(flattened);
            
            csv += headers.join(',') + '\n';
            csv += values.map(v => `"${v}"`).join(',') + '\n';
            
            return csv;
        }

        function jsonToXML(obj, rootName = 'metadata') {
            function objectToXML(obj, indent = '') {
                let xml = '';
                for (const key in obj) {
                    const value = obj[key];
                    const tagName = key.replace(/[^a-zA-Z0-9]/g, '_');
                    
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        xml += `${indent}<${tagName}>\n`;
                        xml += objectToXML(value, indent + '  ');
                        xml += `${indent}</${tagName}>\n`;
                    } else {
                        xml += `${indent}<${tagName}>${value}</${tagName}>\n`;
                    }
                }
                return xml;
            }
            
            return `<?xml version="1.0" encoding="UTF-8"?>\n<${rootName}>\n${objectToXML(obj, '  ')}</${rootName}>`;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
